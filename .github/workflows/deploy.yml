name: Build and Deploy Streamlit Platform
on:
  push:
    branches:
      - main
permissions:
  id-token: write
  contents: read
env:
  AWS_REGION: us-east-1
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for comparison

      - name: Get hash of last successful commit
        id: last-success
        uses: SamKirkland/posts-api-client@v1.0.0
        continue-on-error: true # Allows the workflow to continue on the first run
        with:
          endpoint: |
            /repos/${{ github.repository }}/actions/workflows/${{ github.workflow_id }}/runs?status=success&branch=${{ github.ref_name }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed files since last successful run
        id: changed-apps
        uses: tj-actions/changed-files@v41
        with:
          files: apps/**
          # Use the last successful commit if it exists, otherwise it defaults to an empty string, triggering all files
          base_sha: ${{ fromJson(steps.last-success.outputs.response).workflow_runs[0].head_sha }}

      - name: Install PyYAML for parsing
        run: pip install pyyaml

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: steps.changed-apps.outputs.any_changed == 'true' || steps.last-success.outcome != 'success'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set up Docker Buildx for advanced caching
        if: steps.changed-apps.outputs.any_changed == 'true' || steps.last-success.outcome != 'success'
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        if: steps.changed-apps.outputs.any_changed == 'true' || steps.last-success.outcome != 'success'
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Install SOCI CLI
        if: steps.changed-apps.outputs.any_changed == 'true' || steps.last-success.outcome != 'success'
        run: |
          sudo curl -L -o /usr/local/bin/soci https://github.com/awslabs/soci-snapshotter/releases/download/v0.4.0/soci-linux-amd64
          sudo chmod +x /usr/local/bin/soci

      - name: Build and Push Apps
        if: steps.changed-apps.outputs.any_changed == 'true' || steps.last-success.outcome != 'success'
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          export EXECUTION_ROLE_ARN=$(aws iam get-role --role-name ecsTaskExecutionRole --query 'Role.Arn' --output text)
          export TASK_ROLE_ARN=$EXECUTION_ROLE_ARN

          # Determine which files to process
          if [ "${{ steps.last-success.outcome }}" != "success" ]; then
            echo "--- No successful previous run. Building all apps. ---"
            CHANGED_FILES=$(find apps -mindepth 2 -maxdepth 2 -type f)
          else
            echo "--- Building changed apps only. ---"
            CHANGED_FILES='${{ steps.changed-apps.outputs.all_changed_files }}'
          fi

          declare -A processed_dirs

          for file in $CHANGED_FILES; do
            app_path=$(dirname "$file")
            while [[ "$app_path" != "apps" && "$app_path" != "." ]]; do
                parent_dir=$(dirname "$app_path")
                if [[ "$parent_dir" == "apps" ]]; then
                    break
                fi
                app_path=$parent_dir
            done

            if [[ -z "${processed_dirs[$app_path]}" && "$app_path" != "apps" ]]; then
              processed_dirs[$app_path]=1
              export APP_ID=$(basename "$app_path")
              export ECR_REPOSITORY=$APP_ID
              export IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
              export TASK_FAMILY="${APP_ID}-task"

              MANIFEST_PATH="$app_path/manifest.yaml"
              export ENTRYPOINT_SCRIPT=$(python -c "import yaml; f=open('$MANIFEST_PATH'); d=yaml.safe_load(f); print(d.get('entryPoint', 'app.py'))")
              export REQUIREMENTS_FILE=$(python -c "import yaml; f=open('$MANIFEST_PATH'); d=yaml.safe_load(f); print(d.get('requirements', 'requirements.txt'))")
              export CPU=$(python -c "import yaml; f=open('$MANIFEST_PATH'); d=yaml.safe_load(f); print(d.get('cpu', '256'))")
              export MEMORY=$(python -c "import yaml; f=open('$MANIFEST_PATH'); d=yaml.safe_load(f); print(d.get('memory', '512'))")

              echo "--- Processing app: $APP_ID ---"

              aws ecr create-repository --repository-name $ECR_REPOSITORY --region ${{ env.AWS_REGION }} || true
              docker buildx build --platform linux/amd64 -t $IMAGE_URI \
                --cache-from=type=local,src=/tmp/.buildx-cache \
                --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
                --build-arg APP_DIR="$app_path" \
                --build-arg ENTRYPOINT_SCRIPT="$ENTRYPOINT_SCRIPT" \
                --build-arg REQUIREMENTS_FILE="$REQUIREMENTS_FILE" \
                --push .

              echo "--- Generating and pushing SOCI index for $IMAGE_URI ---"
              soci create $IMAGE_URI
              soci push $IMAGE_URI

              envsubst < task-definition-template.json > "temp-task-def.json"

              aws ecs register-task-definition --cli-input-json file://"temp-task-def.json"
            fi
          done
          # Move new cache to old cache position
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true

      - name: Generate and Deploy Frontend
        run: |
          python scripts/generate_apps_json.py
          aws s3 sync . s3://${{ secrets.S3_BUCKET_NAME }} --exclude "*" --include "index.html" --include "script.js" --include "apps.json" --delete
